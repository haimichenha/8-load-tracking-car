# 模块集成步骤（按 V5.0 引脚规划）

目标：把工程按“先点亮/先读数/再控制”的顺序逐步集成，每一步都能**独立编译 + 上板验证**。

> 你们当前工程里已经有旧代码（mpu6500 / CarRun / MotorRun）。本文建议：**先不删旧文件**，但在 Keil 里把“本阶段不用的 .c”先从 Build 排除或不加入工程组，避免引脚/外设配置冲突。

---

## Step 0：统一引脚（必须先做）

### OLED 的 I2C 引脚冲突
工程里原来的 OLED 软件 I2C 在用 `PB8/PB9`，会和 V5.0 规划的：
- `PB8` 蜂鸣器（TIM4_CH3）
- `PB9` 呼吸灯（TIM4_CH4）
冲突。

已在 [Hardware/OLED.c](../Hardware/OLED.c) 把 OLED I2C 改为：
- `PB10` = SCL
- `PB11` = SDA

这样和八路循迹（I2C）共用同一对线，符合 V5.0。

---

## Step 1：先让 OLED 跑起来

### 需要的文件
- [Hardware/OLED.c](../Hardware/OLED.c)
- [Hardware/OLED.h](../Hardware/OLED.h)
- [Hardware/OLED_Font.h](../Hardware/OLED_Font.h)
- [System/Delay.c](../System/Delay.c)
- [System/Delay.h](../System/Delay.h)

### Keil 里需要做什么
- 把上述 `.c` 加入工程（或确认已加入）
- 确认 `System/Delay.c` 已加入（否则 `delay_init/delay_ms` 会链接失败）

### main 最小验证
- 在 [User/main.c](../User/main.c) 里调用 `delay_init(); OLED_Init(); OLED_ShowString(...)`
- 上电后 OLED 能显示字符串，说明 GPIOB 时钟、PB10/11 开漏输出都 OK。

---

## Step 2：接入“亚博智能八路循迹（I2C）”

### 需要新增/加入的文件
- [Hardware/Tracking.c](../Hardware/Tracking.c)
- [Hardware/Tracking.h](../Hardware/Tracking.h)

### 这个模块会做什么初始化
- 开启 `GPIOB` 时钟
- 配置 `PB10/PB11` 为 `GPIO_Mode_Out_OD`（开漏）
- 使用软件 I2C 在总线上读一个字节：`track_data`（8 位状态）

### 你需要确认的两件事（非常关键）
1) **循迹模块 I2C 地址/寄存器**：当前驱动默认：
- 地址 `0x10`
- 寄存器 `0x01`
如果你拿到的亚博模块不是这个映射，会出现“永远读 0xFF 或 0x00”。

2) **上拉电阻**：PB10/11 必须有上拉（典型 4.7k）。
- 如果模块板载上拉就不用重复加
- 如果没有，上拉缺失会导致读数全错或总线卡死

### main 最小验证
[User/main.c](../User/main.c) 已改为本阶段的最小程序：
- 初始化 `OLED_Init()` + `Tracking_Init()`
- 循环显示 `track_data` 的十六进制

**验收标准：**
- 用手遮挡/压线，`0x??` 会变化

---

## Step 3：接入 TB6612 电机驱动（等循迹读数稳定后再做）

> 你们旧的 [Hardware/MotorRun.c](../Hardware/MotorRun.c) 是另一套电机/引脚/定时器方案（TIM2 多通道）。如果硬件按 V5.0 走 TB6612，请优先用本工程新增的 `Motor.c/h`。

### 需要新增/加入的文件
- [Hardware/Motor.c](../Hardware/Motor.c)
- [Hardware/Motor.h](../Hardware/Motor.h)

### 本驱动匹配的 V5.0 引脚
- PWM：`PA2` = TIM5_CH3，`PA3` = TIM5_CH4
- 方向：`PE2/PE3/PE4/PE5`
- STBY：`PE6`

### 这个模块会做什么初始化
- 开启 `GPIOA/GPIOE` 时钟
- 开启 `TIM5` 时钟
- 配置 PA2/PA3 为复用推挽输出（PWM）
- 配置 PE2~PE6 为推挽输出（方向+使能）
- 配置 TIM5 输出 PWM（当前示例频率约 20kHz）

### main 验证步骤（建议分两小步）
1) **只验证电机能转**：
- 在 `while(1)` 里固定调用 `Motor_SetSpeed(40, 40)`
- 验证左右轮正转、反转、停转

2) **再做循迹闭环**：
- 用 `track_data` 做最简单的左右纠偏（先不用 PID）
- 等能稳定跟线后，再加入 PID（下一阶段）

---

## 关于“零漂处理”你们想参考的点
- 真实“零漂”主要是陀螺仪角速度偏置（bias）。
- 如果你们最终**不使用陀螺仪模块**，那循迹本身不需要零漂处理。
- 如果后续加陀螺仪（比如 JY301P/MPU6050），常见做法是：上电静止时采样 N 次取平均作为 bias，之后每次读数减去 bias。

---

## 推荐的集成顺序（一句话）
OLED 显示 OK → 循迹读数稳定 → 电机能转且方向正确 → 再把循迹与电机组合（先开环纠偏，最后 PID）。
